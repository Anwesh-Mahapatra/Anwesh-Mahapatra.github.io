---
layout: post
title: "Patches & Pointers: Dismantling IOLI Crackme 0x03"
date: 2026-01-12
categories: [Reverse Engineering, Crackmes]
tags: [assembly, x32dbg, stack-frames]
---

**Introduction**

The goal is simple: understand the binary, find the password logic, and patch it. While brute-forcing is an option, in real-world malware analysis, we don't just want the "key", we want to understand the algorithm so we can write detection rules.
We start by executing the binary and entering a test password.

  
![Invalid Password Prompt](/assets/images/1.png)
*Figure 1: The standard "Invalid Password" response.*

  

## Analysis Phase

I loaded the binary into x32dbg. We land at the program's entry point.

![Entry Point](/assets/images/2.png)
  
### String Enumeration
My first move is always to look for interesting strings. I right-clicked the disassembly pane -> Search for -> Current Module -> String references.
![String Search](/assets/images/3.png)
  
We see the string "IOLI Crackme Level 0x03". Double-clicking it takes us to the assembly instruction where this string is used.
![String Assembly](/assets/images/4.png)
  
The instruction mov dword ptr ss:[esp], crackme0x03.404028 pushes the address of the string onto the stack as an argument for printf. Let's verify what lives at memory address 0x404028.

  

### Memory Inspection

I checked the **Memory Map** to see where this address lives. It falls inside the .rdata section.

  ![Memory Map](/assets/images/5.png)

> **Note:** `.rdata` (Read-Only Data) stores constants that persist for the program's life. Unlike `.data`, this section is usually not modified during runtime.

  

Hovering over the address in the dump confirms the Little Endian ASCII values:
![Hex Dump](/assets/images/6.png)
  


* `0x49` = **I** * `0x4C` = **L** * `0x4F` = **O** * `0x49` = **I**

  

This confirms we are looking at the "Header" text of the crackme.

  

## Dynamic Analysis

I set a breakpoint at the function prologue (push ebp) to trace the execution flow.

  ![Breakpoint Set](/assets/images/7.png)

Running the program hits the breakpoint. I stepped over (F8) the printf calls until I hit scanf. This is where the program pauses and waits for user input.
![Debugger Paused](/assets/images/8.png) ![Console Input](/assets/images/9.png)
  

I entered 1234. The debugger paused again, allowing me to inspect the state immediately after input.

  

### The Stack Frame & Scanf

The `scanf` call is interesting here:

  
```
lea eax, dword ptr ss:[ebp-4] 
mov dword ptr ss:[esp+4], eax 
mov dword ptr ss:[esp], crackme0x03.40404C 
call <JMP.&scanf>
```
  

```lea eax, [ebp-4]```: This loads the address of a local variable (located on the stack at ebp-4) into EAX.
```mov [esp+4], eax```: This passes that address as the 2nd argument to scanf.
**Result**: scanf writes my input (1234 or hex 0x4D2) directly into the stack memory at ebp-4.

  

We can verify this by looking at the stack view. My input 04D2 is sitting right there at address 0060FF24.
![Stack View](/assets/images/10.png)
  

This confirms the program uses stack variables for local storage rather than the .data section.

  

### The Key Generation Logic

After scanf, we hit the core logic block. This is where the program generates the "Real" password to compare against my input.

```mov dword ptr ss:[ebp-8], 5A
mov dword ptr ss:[ebp-C], 1EC
mov edx, dword ptr ss:[ebp-C]
lea eax, dword ptr ss:[ebp-8]
add dword ptr ds:[eax], edx
mov eax, dword ptr ss:[ebp-8]
imul eax, dword ptr ss:[ebp-8]
mov dword ptr ss:[ebp-C], eax
```

  

### Explaining the Assembly
This block performs a specific mathematical sequence to generate the valid key:
1.  Initialization: It creates two variables on the stack.
    -   Var_A (ebp-8) = 0x5A (Decimal 90)
    -   Var_B (ebp-C) = 0x1EC (Decimal 492)
        
2.  Addition: It takes the address of Var_A (LEA) and adds the value of Var_B to it.
    -   90 + 492 = 582
3.  Multiplication: It overwrites Var_A with this new sum, then multiplies it by itself (Square).
    -   582 * 582 = 338,724
4.  Storage: The result (338724) is stored in Var_B.
This means the correct password is 338724.

  

### The Check Function

The program then calls a sub-function at 40136A to verify the password. I entered this function to see the comparison.
![Check Function](/assets/images/11.png)
  
```
cmp eax, dword ptr ss:[ebp+C] 
je crackme0x03.401386
```
It compares EAX (My Input) with [ebp+C] (The Calculated Key).

  

```EAX: 0x4D2 (1234)```
```[ebp+C]: 0x52B24  (338724)```

  
![Reg State](/assets/images/12.png) ![Stack Value](/assets/images/13.png)
Since they don't match, the ZF (Zero Flag) is not set, and the JE (Jump if Equal) fails.

  

### Patching the Binary

To crack this, we don't need the password. We can force the logic flow to accept any password.

I modified the conditional jump instruction:
-   Original: JE 401386 (Jump only if equal)
-   Patched: JMP 401386 (Jump always)
![Patch](/assets/images/14.png)


I saved the patched binary to a new file.

![Save](/assets/images/15.png)

**Verification**

Running the patched binary with the incorrect password 1234 now yields success.

![Success](/assets/images/16.png)

We have successfully bypassed the logic protection. In the next post, I will explore more complex control flows involving loops.